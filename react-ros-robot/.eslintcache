[{"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/index.js":"1","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/App.js":"2","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/reportWebVitals.js":"3","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Header.jsx":"4","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Body.jsx":"5","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Footer.jsx":"6","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Map.jsx":"7","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Home.jsx":"8","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/About.jsx":"9","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Connection.jsx":"10","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Teleoperation.jsx":"11","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Navigation.jsx":"12","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/RobotState.jsx":"13","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/RelayControl.jsx":"14","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/scripts/config.js":"15","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/vendor/nav2d.js":"16","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/vendor/ros2d.js":"17"},{"size":544,"mtime":1620829636057,"results":"18","hashOfConfig":"19"},{"size":270,"mtime":1621696900116,"results":"20","hashOfConfig":"19"},{"size":362,"mtime":1619338743456,"results":"21","hashOfConfig":"19"},{"size":686,"mtime":1622399014137,"results":"22","hashOfConfig":"19"},{"size":702,"mtime":1620745563891,"results":"23","hashOfConfig":"19"},{"size":301,"mtime":1621696900116,"results":"24","hashOfConfig":"19"},{"size":1184,"mtime":1622565836175,"results":"25","hashOfConfig":"19"},{"size":1321,"mtime":1622566630075,"results":"26","hashOfConfig":"19"},{"size":685,"mtime":1621696900116,"results":"27","hashOfConfig":"19"},{"size":1809,"mtime":1622399014137,"results":"28","hashOfConfig":"19"},{"size":3006,"mtime":1620485711229,"results":"29","hashOfConfig":"19"},{"size":1166,"mtime":1622565802428,"results":"30","hashOfConfig":"19"},{"size":4804,"mtime":1622566559888,"results":"31","hashOfConfig":"19"},{"size":8114,"mtime":1622564057540,"results":"32","hashOfConfig":"19"},{"size":444,"mtime":1622407065050,"results":"33","hashOfConfig":"19"},{"size":12118,"mtime":1622408115342,"results":"34","hashOfConfig":"19"},{"size":35116,"mtime":1622489161649,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"xc3pop",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"38"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"38"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"38"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"38"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"38"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"38"},"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/index.js",[],["78","79"],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/App.js",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/reportWebVitals.js",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Header.jsx",["80"],"import React, { Component } from \"react\";\nimport {Container, Navbar, Nav, TabContainer} from \"react-bootstrap\";\n\nclass Header extends Component {\n  render() {\n    return ( \n    <Container>\n    <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\" collapseOnSelect>\n    <Navbar.Brand href=\"#home\">Web Interface</Navbar.Brand>\n    <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n    <Navbar.Collapse id=\"basic-navbar-nav\">\n      <Nav className=\"mr-auto\">\n        <Nav.Link href=\"/\">Home</Nav.Link>\n        <Nav.Link href=\"/Map\">Map</Nav.Link>\n        <Nav.Link href=\"/About\">About</Nav.Link>\n      </Nav>\n    </Navbar.Collapse>\n  </Navbar>\n  </Container>\n  \n   );\n  }\n}\n\nexport default Header;\n","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Body.jsx",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Footer.jsx",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Map.jsx",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Home.jsx",["81"],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/About.jsx",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Connection.jsx",["82","83"],"import { thisExpression } from '@babel/types';\nimport React, {Component } from 'react';\nimport Alert from 'react-bootstrap/Alert';\nimport Config from '../scripts/config';\n\nclass Connection extends Component {\n    state = {\n        connected: false,\n        ros: null\n    }\n\n    constructor(){\n        super();\n        this.init_connection();\n    }\n\n    init_connection(){\n        this.state.ros = new window.ROSLIB.Ros();\n        console.log(this.state.ros);\n        \n        this.state.ros.on(\"connection\", () => {\n            console.log(\"connection established!\");\n            this.setState({ connected: true});\n\n        });\n\n        this.state.ros.on(\"close\", () => {\n            console.log(\"connection closed!\");\n            this.setState({ connected: false});\n\n            //try to reconnect every 3 seconds \n            setTimeout(() => {\n                try{\n                    this.state.ros.connect(\"ws://\"+\n                    Config.ROSBRIDGE_SERVER_IP+\":\"+\n                    Config.ROSBRIDGE_SERVER_PORT+\"\"\n                    );\n                }catch (error){\n                    console.log(\"connection problem\");\n                }\n            }, Config.RECONNECTION_TIMER);\n\n        });\n\n        try{\n            this.state.ros.connect(\"ws://\"+\n            Config.ROSBRIDGE_SERVER_IP+\":\"+\n            Config.ROSBRIDGE_SERVER_PORT+\"\"\n            );\n        }catch (error){\n            console.log(\"connection problem\");\n        } \n    }\n\n    render() {\n        return (\n            <div>\n                <Alert className=\"text-center m-3\" variant={this.state.connected ? \"success\": \"danger\"}>\n                    {this.state.connected? \"Robot connected\" : \"Robot disconnected\"}\n                </Alert>\n                \n            </div>\n        );\n    }\n  \n}\n\nexport default Connection;\n","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Teleoperation.jsx",["84"],"import React, { Component } from \"react\";\nimport { Joystick } from \"react-joystick-component\";\nimport Config from '../scripts/config';\n\n\nclass Teleoperation extends Component {\n\n    state = { ros: null };\n\n    constructor(){\n        super();\n        this.init_connection();\n        this.handleMove = this.handleMove.bind(this);\n        this.handleStop = this.handleStop.bind(this);\n    }\n\n    init_connection(){\n        this.state.ros = new window.ROSLIB.Ros();\n        console.log(this.state.ros);\n        \n        this.state.ros.on(\"connection\", () => {\n            console.log(\"connection established in Teleoperation Companenet!\");\n            console.log(this.state.ros);\n            this.setState({ connected: true});\n\n        });\n\n        this.state.ros.on(\"close\", () => {\n            console.log(\"connection closed!\");\n            this.setState({ connected: false});\n\n            //try to reconnect every 3 seconds \n            setTimeout(() => {\n                try{\n                    this.state.ros.connect(\"ws://\"+\n                    Config.ROSBRIDGE_SERVER_IP+\":\"+\n                    Config.ROSBRIDGE_SERVER_PORT+\"\"\n                    );\n                }catch (error){\n                    console.log(\"connection problem\");\n                }\n            }, Config.RECONNECTION_TIMER);\n\n        });\n        try{\n            this.state.ros.connect(\"ws://\"+\n            Config.ROSBRIDGE_SERVER_IP+\":\"+\n            Config.ROSBRIDGE_SERVER_PORT+\"\"\n            );\n        }catch (error){\n            console.log(\"connection problem\");\n        }\n    }\n\n    // methods\n    handleMove(event) {\n        console.log(\"hanle move\");\n        var cmd_vel = new window.ROSLIB.Topic({\n            ros: this.state.ros,\n            name: Config.CMD_VEL_TOPIC,\n            messageType: \"geometry_msgs/Twist\",\n        });\n\n        var twist = new window.ROSLIB.Message({\n            linear:{\n                x: event.y / 50,\n                y: 0,\n                z: 0,\n            },\n            angular:{\n                x: 0,\n                y: 0,\n                z: -event.x / 50,\n            },\n        });\n\n        cmd_vel.publish(twist)\n    }\n\n    handleStop(event) {\n        console.log(\"hanle stop\");\n        var cmd_vel = new window.ROSLIB.Topic({\n            ros: this.state.ros,\n            name: Config.CMD_VEL_TOPIC,\n            messageType: \"geometry_msgs/Twist\",\n        });\n\n        var twist = new window.ROSLIB.Message({\n            linear:{\n                x: 0,\n                y: 0,\n                z: 0,\n            },\n            angular:{\n                x: 0,\n                y: 0,\n                z: 0,\n            },\n        });\n\n        cmd_vel.publish(twist)\n    }\n\n    render() {\n        return <div>\n            <Joystick\n                size={100}\n                baseColor=\"black\"\n                stickColor=\"orange\"\n                move={this.handleMove}\n                stop={this.handleStop}\n            ></Joystick>\n        </div>;\n    }\n}\n\nexport default Teleoperation;\n","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/Navigation.jsx",["85"],"import React, { Component } from \"react\";\nimport NAV2D from './vendor/nav2d.js'\nimport ROS2D from './vendor/ros2d.js'\nimport PropTypes from 'prop-types';\nimport ROSLIB from 'roslib'\n\nclass Navigation extends Component {\n\n  componentDidMount() {\n    const ros = this.props.ros;\n\n    // Create the main viewer.\n    const viewer = new ROS2D.Viewer({\n      divID: this.props.id,\n      width: this.props.width,\n      height: this.props.height\n    });\n\n    // Setup the nav client.\n    var nav = NAV2D.OccupancyGridClientNav({\n      ros: ros,\n      rootObject: viewer.scene,\n      topic: this.props.topic,\n      viewer: viewer,\n      serverName: this.props.serverName\n    });\n  }\n\n  render() {\n    return (\n      <>\n        <div id={this.props.id} />\n      </>\n    );\n  }\n}\n\nNavigation.defaultProps = {\n  ros: new ROSLIB.Ros({\n    url: 'ws://localhost:9090'\n  }),\n  id: 'nav2d',\n  width: 500,\n  height: 500,\n  topic: '/map',\n  serverName: '/move_base'\n};\n\nNavigation.propTypes = {\n  ros: PropTypes.object,\n  id: PropTypes.string,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  topic: PropTypes.string,\n  serverName: PropTypes.string\n}\n\nexport default Navigation;","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/RobotState.jsx",["86","87","88"],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/RelayControl.jsx",["89"],"import React, { Component } from \"react\";\nimport { Button } from \"react-bootstrap\"\nimport Config from '../scripts/config';\n\nclass RelayControl extends Component {\n  state = {\n    ros: null,\n  };\n\n  constructor() {\n    super();\n    this.init_connection();\n    this.handleOpen_1 = this.handleOpen_1.bind(this);\n    this.handleClose_1 = this.handleClose_1.bind(this);\n    this.handleOpen_2 = this.handleOpen_2.bind(this);\n    this.handleClose_2 = this.handleClose_2.bind(this);\n    this.handleOpen_3 = this.handleOpen_3.bind(this);\n    this.handleClose_3 = this.handleClose_3.bind(this);\n    this.handleOpen_4 = this.handleOpen_4.bind(this);\n    this.handleClose_4 = this.handleClose_4.bind(this);\n    this.handleOpen_5 = this.handleOpen_5.bind(this);\n    this.handleClose_5 = this.handleClose_5.bind(this);\n    this.handleOpen_6 = this.handleOpen_6.bind(this);\n    this.handleClose_6 = this.handleClose_6.bind(this);\n    this.handleOpen_7 = this.handleOpen_7.bind(this);\n    this.handleClose_7 = this.handleClose_7.bind(this);\n    this.handleOpen_8 = this.handleOpen_8.bind(this);\n    this.handleClose_8 = this.handleClose_8.bind(this);\n  };\n\n  init_connection() {\n    this.state.ros = new window.ROSLIB.Ros();\n    console.log(this.state.ros);\n\n    this.state.ros.on(\"connection\", () => {\n      console.log(\"connection established in Teleoperation Companenet!\");\n      console.log(this.state.ros);\n      this.setState({ connected: true });\n\n    });\n\n    this.state.ros.on(\"close\", () => {\n      console.log(\"connection closed!\");\n      this.setState({ connected: false });\n\n      //try to reconnect every 3 seconds\n      setTimeout(() => {\n        try {\n          this.state.ros.connect(\"ws://\" +\n            Config.ROSBRIDGE_SERVER_IP + \":\" +\n            Config.ROSBRIDGE_SERVER_PORT + \"\"\n          );\n        } catch (error) {\n          console.log(\"connection problem\");\n        }\n      }, Config.RECONNECTION_TIMER);\n\n    });\n    try {\n      this.state.ros.connect(\"ws://\" +\n        Config.ROSBRIDGE_SERVER_IP + \":\" +\n        Config.ROSBRIDGE_SERVER_PORT + \"\"\n      );\n    } catch (error) {\n      console.log(\"connection problem\");\n    }\n  }\n\n  // methods\n  handleOpen_1() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_1\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_1() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_1\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_2() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_2\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_2() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_2\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_3() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_3\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_3() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_3\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_4() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_4\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_4() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_4\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_5() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_5\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_5() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_5\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_6() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_6\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_6() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_6\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_7() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_7\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_7() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_7\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  handleOpen_8() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_8\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: true\n    });\n    relay_pub.publish(str);\n  }\n  handleClose_8() {\n    var relay_pub = new window.ROSLIB.Topic({\n      ros: this.state.ros,\n      name: \"/r5/open_relay_8\",\n      messageType: 'std_msgs/Bool',\n    });\n\n    var str = new window.ROSLIB.Message({\n      data: false\n    });\n    relay_pub.publish(str);\n  }\n\n  render() {\n    return (\n      <>\n        <div className=\"mb-5\"></div>\n        <h4 className=\"mb-2\">RELAY CONTROL</h4>\n        <Button variant=\"success\" onClick={this.handleOpen_1}>Relay 1</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_1} >Relay 1</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_2} >Relay 2</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_2}>Relay 2</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_3}>Relay 3</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_3}>Relay 3</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_4}>Relay 4</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_4}>Relay 4</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_5}>Relay 5</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_5}>Relay 5</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_6}>Relay 6</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_6}>Relay 6</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_7}>Relay 7</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_7}>Relay 7</Button>{' '}\n        <ol></ol>\n        <Button variant=\"success\" onClick={this.handleOpen_8}>Relay 8</Button>{' '}\n        <Button variant=\"danger\" onClick={this.handleClose_8}>Relay 8</Button>{' '}\n      </>\n    );\n  }\n}\n\nexport default RelayControl;","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/scripts/config.js",[],"/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/vendor/nav2d.js",["90"],"import 'latest-createjs'\nimport ROS2D from './ros2d'\nimport ROSLIB from 'roslib'\nimport createjs from 'createjs-module';\nimport Config from '../../scripts/config';\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n * @author Lars Kunze - l.kunze@cs.bham.ac.uk\n */\n\nvar NAV2D = NAV2D || {\n  REVISION : '0.3.0'\n};\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A OccupancyGridClientNav uses an OccupancyGridClient to create a map for use with a Navigator.\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * topic (optional) - the map meta data topic to listen to\n *   * image - the URL of the image to render\n *   * serverName (optional) - the action server name to use for navigation, like '/move_base'\n *   * actionName (optional) - the navigation action name, like 'move_base_msgs/MoveBaseAction'\n *   * rootObject (optional) - the root object to add the click listeners to and render robot markers to\n *   * withOrientation (optional) - if the Navigator should consider the robot orientation (default: false)\n *   * viewer - the main viewer to render to\n */\nNAV2D.ImageMapClientNav = function(options) {\n  var that = this;\n  options = options || {};\n  this.ros = options.ros;\n  var topic = options.topic || '/map_metadata';\n  var image = options.image;\n  this.serverName = options.serverName || '/move_base';\n  this.actionName = options.actionName || 'move_base_msgs/MoveBaseAction';\n  this.rootObject = options.rootObject || new createjs.Container();\n  this.viewer = options.viewer;\n  this.withOrientation = options.withOrientation || false;\n\n  this.navigator = null;\n\n  // setup a client to get the map\n  var client = new ROS2D.ImageMapClient({\n    ros : this.ros,\n    rootObject : this.rootObject,\n    topic : topic,\n    image : image\n  });\n  client.on('change', function() {\n    that.navigator = new NAV2D.Navigator({\n      ros : that.ros,\n      serverName : that.serverName,\n      actionName : that.actionName,\n      rootObject : that.rootObject,\n      withOrientation : that.withOrientation\n    });\n\n    // scale the viewer to fit the map\n    that.viewer.scaleToDimensions(client.currentImage.width, client.currentImage.height);\n    that.viewer.shift(client.currentImage.pose.position.x, client.currentImage.pose.position.y);\n  });\n};\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n * @author Lars Kunze - l.kunze@cs.bham.ac.uk\n */\n\n/**\n * A navigator can be used to add click-to-navigate options to an object. If\n * withOrientation is set to true, the user can also specify the orientation of\n * the robot by clicking at the goal position and pointing into the desired\n * direction (while holding the button pressed).\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * serverName (optional) - the action server name to use for navigation, like '/move_base'\n *   * actionName (optional) - the navigation action name, like 'move_base_msgs/MoveBaseAction'\n *   * rootObject (optional) - the root object to add the click listeners to and render robot markers to\n *   * withOrientation (optional) - if the Navigator should consider the robot orientation (default: false)\n */\nNAV2D.Navigator = function(options) {\n  var that = this;\n  options = options || {};\n  var ros = options.ros;\n  var serverName = options.serverName || '/move_base';\n  var actionName = options.actionName || 'move_base_msgs/MoveBaseAction';\n  var withOrientation = options.withOrientation || false;\n  this.rootObject = options.rootObject || new createjs.Container();\n\n  // setup the actionlib client\n  var actionClient = new ROSLIB.ActionClient({\n    ros : ros,\n    actionName : actionName,\n    serverName : serverName\n  });\n\n  /**\n   * Send a goal to the navigation stack with the given pose.\n   *\n   * @param pose - the goal pose\n   */\n  function sendGoal(pose) {\n    // create a goal\n    var goal = new ROSLIB.Goal({\n      actionClient : actionClient,\n      goalMessage : {\n        target_pose : {\n          header : {\n            frame_id : Config.MAP_TOPIC_FOR_MAP_GOAL\n          },\n          pose : pose\n        }\n      }\n    });\n    goal.send();\n\n    // create a marker for the goal\n    var goalMarker = new ROS2D.NavigationArrow({\n      size : 15,\n      strokeSize : 1,\n      fillColor : createjs.Graphics.getRGB(255, 64, 128, 0.66),\n      pulse : true\n    });\n    goalMarker.x = pose.position.x;\n    goalMarker.y = -pose.position.y;\n    goalMarker.rotation = stage.rosQuaternionToGlobalTheta(pose.orientation);\n    goalMarker.scaleX = 1.0 / stage.scaleX;\n    goalMarker.scaleY = 1.0 / stage.scaleY;\n    that.rootObject.addChild(goalMarker);\n\n    goal.on('result', function() {\n      that.rootObject.removeChild(goalMarker);\n    });\n  }\n\n  // get a handle to the stage\n  var stage;\n  if (that.rootObject instanceof createjs.Stage) {\n    stage = that.rootObject;\n  } else {\n    stage = that.rootObject.getStage();\n  }\n\n  // marker for the robot\n  var robotMarker = new ROS2D.NavigationArrow({\n    size : 25,\n    strokeSize : 1,\n    fillColor : createjs.Graphics.getRGB(255, 128, 0, 0.66),\n    pulse : true\n  });\n  // wait for a pose to come in first\n  robotMarker.visible = false;\n  this.rootObject.addChild(robotMarker);\n  var initScaleSet = false;\n\n  // setup a listener for the robot pose\n  var poseListener = new ROSLIB.Topic({\n    ros : ros,\n    name : '/robot_pose',\n    messageType : 'geometry_msgs/Pose',\n    throttle_rate : 100\n  });\n  poseListener.subscribe(function(pose) {\n    // update the robots position on the map\n    robotMarker.x = pose.position.x;\n    robotMarker.y = -pose.position.y;\n    if (!initScaleSet) {\n      robotMarker.scaleX = 1.0 / stage.scaleX;\n      robotMarker.scaleY = 1.0 / stage.scaleY;\n      initScaleSet = true;\n    }\n\n    // change the angle\n    robotMarker.rotation = stage.rosQuaternionToGlobalTheta(pose.orientation);\n\n    robotMarker.visible = true;\n  });\n\n  if (withOrientation === false){\n    // setup a double click listener (no orientation)\n    this.rootObject.addEventListener('dblclick', function(event) {\n      // convert to ROS coordinates\n      var coords = stage.globalToRos(event.stageX, event.stageY);\n      var pose = new ROSLIB.Pose({\n        position : new ROSLIB.Vector3(coords)\n      });\n      // send the goal\n      sendGoal(pose);\n    });\n  } else { // withOrientation === true\n    // setup a click-and-point listener (with orientation)\n    var position = null;\n    var positionVec3 = null;\n    var thetaRadians = 0;\n    var thetaDegrees = 0;\n    var orientationMarker = null;\n    var mouseDown = false;\n    var xDelta = 0;\n    var yDelta = 0;\n\n    var mouseEventHandler = function(event, mouseState) {\n\n      if (mouseState === 'down'){\n        // get position when mouse button is pressed down\n        position = stage.globalToRos(event.stageX, event.stageY);\n        positionVec3 = new ROSLIB.Vector3(position);\n        mouseDown = true;\n      }\n      else if (mouseState === 'move'){\n        // remove obsolete orientation marker\n        that.rootObject.removeChild(orientationMarker);\n        \n        if ( mouseDown === true) {\n          // if mouse button is held down:\n          // - get current mouse position\n          // - calulate direction between stored <position> and current position\n          // - place orientation marker\n          var currentPos = stage.globalToRos(event.stageX, event.stageY);\n          var currentPosVec3 = new ROSLIB.Vector3(currentPos);\n\n          orientationMarker = new ROS2D.NavigationArrow({\n            size : 25,\n            strokeSize : 1,\n            fillColor : createjs.Graphics.getRGB(0, 255, 0, 0.66),\n            pulse : false\n          });\n\n          xDelta =  currentPosVec3.x - positionVec3.x;\n          yDelta =  currentPosVec3.y - positionVec3.y;\n          \n          thetaRadians  = Math.atan2(xDelta,yDelta);\n\n          thetaDegrees = thetaRadians * (180.0 / Math.PI);\n          \n          if (thetaDegrees >= 0 && thetaDegrees <= 180) {\n            thetaDegrees += 270;\n          } else {\n            thetaDegrees -= 90;\n          }\n\n          orientationMarker.x =  positionVec3.x;\n          orientationMarker.y = -positionVec3.y;\n          orientationMarker.rotation = thetaDegrees;\n          orientationMarker.scaleX = 1.0 / stage.scaleX;\n          orientationMarker.scaleY = 1.0 / stage.scaleY;\n          \n          that.rootObject.addChild(orientationMarker);\n        }\n      } else if (mouseDown) { // mouseState === 'up'\n        // if mouse button is released\n        // - get current mouse position (goalPos)\n        // - calulate direction between stored <position> and goal position\n        // - set pose with orientation\n        // - send goal\n        mouseDown = false;\n\n        var goalPos = stage.globalToRos(event.stageX, event.stageY);\n\n        var goalPosVec3 = new ROSLIB.Vector3(goalPos);\n        \n        xDelta =  goalPosVec3.x - positionVec3.x;\n        yDelta =  goalPosVec3.y - positionVec3.y;\n        \n        thetaRadians  = Math.atan2(xDelta,yDelta);\n        \n        if (thetaRadians >= 0 && thetaRadians <= Math.PI) {\n          thetaRadians += (3 * Math.PI / 2);\n        } else {\n          thetaRadians -= (Math.PI/2);\n        }\n        \n        var qz =  Math.sin(-thetaRadians/2.0);\n        var qw =  Math.cos(-thetaRadians/2.0);\n        \n        var orientation = new ROSLIB.Quaternion({x:0, y:0, z:qz, w:qw});\n        \n        var pose = new ROSLIB.Pose({\n          position :    positionVec3,\n          orientation : orientation\n        });\n        // send the goal\n        sendGoal(pose);\n      }\n    };\n\n    this.rootObject.addEventListener('stagemousedown', function(event) {\n      mouseEventHandler(event,'down');\n    });\n\n    this.rootObject.addEventListener('stagemousemove', function(event) {\n      mouseEventHandler(event,'move');\n    });\n\n    this.rootObject.addEventListener('stagemouseup', function(event) {\n      mouseEventHandler(event,'up');\n    });\n  }\n};\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A OccupancyGridClientNav uses an OccupancyGridClient to create a map for use with a Navigator.\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * topic (optional) - the map topic to listen to\n *   * rootObject (optional) - the root object to add this marker to\n *   * continuous (optional) - if the map should be continuously loaded (e.g., for SLAM)\n *   * serverName (optional) - the action server name to use for navigation, like '/move_base'\n *   * actionName (optional) - the navigation action name, like 'move_base_msgs/MoveBaseAction'\n *   * rootObject (optional) - the root object to add the click listeners to and render robot markers to\n *   * withOrientation (optional) - if the Navigator should consider the robot orientation (default: false)\n *   * viewer - the main viewer to render to\n */\nNAV2D.OccupancyGridClientNav = function(options) {\n  var that = this;\n  options = options || {};\n  this.ros = options.ros;\n  var topic = options.topic || '/map';\n  var continuous = options.continuous;\n  this.serverName = options.serverName || '/move_base';\n  this.actionName = options.actionName || 'move_base_msgs/MoveBaseAction';\n  this.rootObject = options.rootObject || new createjs.Container();\n  this.viewer = options.viewer;\n  this.withOrientation = options.withOrientation || false;\n\n  this.navigator = null;\n\n  // setup a client to get the map\n  var client = new ROS2D.OccupancyGridClient({\n    ros : this.ros,\n    rootObject : this.rootObject,\n    continuous : continuous,\n    topic : topic\n  });\n  client.on('change', function() {\n    that.navigator = new NAV2D.Navigator({\n      ros : that.ros,\n      serverName : that.serverName,\n      actionName : that.actionName,\n      rootObject : that.rootObject,\n      withOrientation : that.withOrientation\n    });\n    \n    // scale the viewer to fit the map\n    that.viewer.scaleToDimensions(client.currentGrid.width, client.currentGrid.height);\n    that.viewer.shift(client.currentGrid.pose.position.x, client.currentGrid.pose.position.y);\n  });\n};\n\nexport default NAV2D","/home/salih/ros_workspace/ros_web_interface/src/udemy_course/react-ros-robot/src/components/vendor/ros2d.js",["91","92","93"],"import 'latest-createjs'\nimport ROSLIB from 'roslib'\nimport EventEmitter2 from 'eventemitter2'\nimport createjs from 'createjs-module';\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\nvar ROS2D = ROS2D || {\n  REVISION : '0.9.0'\n};\n\n// convert the given global Stage coordinates to ROS coordinates\ncreatejs.Stage.prototype.globalToRos = function(x, y) {\n  var rosX = (x - this.x) / this.scaleX;\n  var rosY = (this.y - y) / this.scaleY;\n  return new ROSLIB.Vector3({\n    x : rosX,\n    y : rosY\n  });\n};\n\n// convert the given ROS coordinates to global Stage coordinates\ncreatejs.Stage.prototype.rosToGlobal = function(pos) {\n  var x = pos.x * this.scaleX + this.x;\n  var y = pos.y * this.scaleY + this.y;\n  return {\n    x : x,\n    y : y\n  };\n};\n\n// convert a ROS quaternion to theta in degrees\ncreatejs.Stage.prototype.rosQuaternionToGlobalTheta = function(orientation) {\n  // See https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Rotation_matrices\n  // here we use [x y z] = R * [1 0 0]\n  var q0 = orientation.w;\n  var q1 = orientation.x;\n  var q2 = orientation.y;\n  var q3 = orientation.z;\n  // Canvas rotation is clock wise and in degrees\n  return -Math.atan2(2 * (q0 * q3 + q1 * q2), 1 - 2 * (q2 * q2 + q3 * q3)) * 180.0 / Math.PI;\n};\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * An image map is a PNG image scaled to fit to the dimensions of a OccupancyGrid.\n *\n * @constructor\n * @param options - object with following keys:\n *   * message - the occupancy grid map meta data message\n *   * image - the image URL to load\n */\nROS2D.ImageMap = function(options) {\n  options = options || {};\n  var message = options.message;\n  var image = options.image;\n\n  // save the metadata we need\n  this.pose = new ROSLIB.Pose({\n    position : message.origin.position,\n    orientation : message.origin.orientation\n  });\n\n  // set the size\n  this.width = message.width;\n  this.height = message.height;\n\n  // create the bitmap\n  createjs.Bitmap.call(this, image);\n  // change Y direction\n  this.y = -this.height * message.resolution;\n\n  // scale the image\n  this.scaleX = message.resolution;\n  this.scaleY = message.resolution;\n  this.width *= this.scaleX;\n  this.height *= this.scaleY;\n\n  // set the pose\n  this.x += this.pose.position.x;\n  this.y -= this.pose.position.y;\n};\nROS2D.ImageMap.prototype.__proto__ = createjs.Bitmap.prototype;\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A image map is a PNG image scaled to fit to the dimensions of a OccupancyGrid.\n *\n * Emits the following events:\n *   * 'change' - there was an update or change in the map\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * topic (optional) - the map meta data topic to listen to\n *   * image - the image URL to load\n *   * rootObject (optional) - the root object to add this marker to\n */\nROS2D.ImageMapClient = function(options) {\n  var that = this;\n  options = options || {};\n  var ros = options.ros;\n  var topic = options.topic || '/map_metadata';\n  this.image = options.image;\n  this.rootObject = options.rootObject || new createjs.Container();\n\n  // create an empty shape to start with\n  this.currentImage = new createjs.Shape();\n\n  // subscribe to the topic\n  var rosTopic = new ROSLIB.Topic({\n    ros : ros,\n    name : topic,\n    messageType : 'nav_msgs/MapMetaData'\n  });\n\n  rosTopic.subscribe(function(message) {\n    // we only need this once\n    rosTopic.unsubscribe();\n\n    // create the image\n    that.currentImage = new ROS2D.ImageMap({\n      message : message,\n      image : that.image\n    });\n    that.rootObject.addChild(that.currentImage);\n    // work-around for a bug in easeljs -- needs a second object to render correctly\n    that.rootObject.addChild(new ROS2D.Grid({size:1}));\n\n    that.emit('change');\n  });\n};\nROS2D.ImageMapClient.prototype.__proto__ = EventEmitter2.prototype;\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * An OccupancyGrid can convert a ROS occupancy grid message into a createjs Bitmap object.\n *\n * @constructor\n * @param options - object with following keys:\n *   * message - the occupancy grid message\n */\nROS2D.OccupancyGrid = function(options) {\n  options = options || {};\n  var message = options.message;\n\n  // internal drawing canvas\n  var canvas = document.createElement('canvas');\n  var context = canvas.getContext('2d');\n\n  // save the metadata we need\n  this.pose = new ROSLIB.Pose({\n    position : message.info.origin.position,\n    orientation : message.info.origin.orientation\n  });\n\n  // set the size\n  this.width = message.info.width;\n  this.height = message.info.height;\n  canvas.width = this.width;\n  canvas.height = this.height;\n\n  var imageData = context.createImageData(this.width, this.height);\n  for ( var row = 0; row < this.height; row++) {\n    for ( var col = 0; col < this.width; col++) {\n      // determine the index into the map data\n      var mapI = col + ((this.height - row - 1) * this.width);\n      // determine the value\n      var data = message.data[mapI];\n      var val;\n      if (data === 100) {\n        val = 0;\n      } else if (data === 0) {\n        val = 255;\n      } else {\n        val = 127;\n      }\n\n      // determine the index into the image data array\n      var i = (col + (row * this.width)) * 4;\n      // r\n      imageData.data[i] = val;\n      // g\n      imageData.data[++i] = val;\n      // b\n      imageData.data[++i] = val;\n      // a\n      imageData.data[++i] = 255;\n    }\n  }\n  context.putImageData(imageData, 0, 0);\n\n  // create the bitmap\n  createjs.Bitmap.call(this, canvas);\n  // change Y direction\n  this.y = -this.height * message.info.resolution;\n  \n  // scale the image\n  this.scaleX = message.info.resolution;\n  this.scaleY = message.info.resolution;\n  this.width *= this.scaleX;\n  this.height *= this.scaleY;\n\n  // set the pose\n  this.x += this.pose.position.x;\n  this.y -= this.pose.position.y;\n};\nROS2D.OccupancyGrid.prototype.__proto__ = createjs.Bitmap.prototype;\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A map that listens to a given occupancy grid topic.\n *\n * Emits the following events:\n *   * 'change' - there was an update or change in the map\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * topic (optional) - the map topic to listen to\n *   * rootObject (optional) - the root object to add this marker to\n *   * continuous (optional) - if the map should be continuously loaded (e.g., for SLAM)\n */\nROS2D.OccupancyGridClient = function(options) {\n  var that = this;\n  options = options || {};\n  var ros = options.ros;\n  var topic = options.topic || '/map';\n  this.continuous = options.continuous;\n  this.rootObject = options.rootObject || new createjs.Container();\n\n  // current grid that is displayed\n  // create an empty shape to start with, so that the order remains correct.\n  this.currentGrid = new createjs.Shape();\n  this.rootObject.addChild(this.currentGrid);\n  // work-around for a bug in easeljs -- needs a second object to render correctly\n  this.rootObject.addChild(new ROS2D.Grid({size:1}));\n\n  // subscribe to the topic\n  var rosTopic = new ROSLIB.Topic({\n    ros : ros,\n    name : topic,\n    messageType : 'nav_msgs/OccupancyGrid',\n    compression : 'png'\n  });\n\n  rosTopic.subscribe(function(message) {\n    // check for an old map\n    var index = null;\n    if (that.currentGrid) {\n      index = that.rootObject.getChildIndex(that.currentGrid);\n      that.rootObject.removeChild(that.currentGrid);\n    }\n\n    that.currentGrid = new ROS2D.OccupancyGrid({\n      message : message\n    });\n    if (index !== null) {\n      that.rootObject.addChildAt(that.currentGrid, index);\n    }\n    else {\n      that.rootObject.addChild(that.currentGrid);\n    }\n\n    that.emit('change');\n\n    // check if we should unsubscribe\n    if (!that.continuous) {\n      rosTopic.unsubscribe();\n    }\n  });\n};\nROS2D.OccupancyGridClient.prototype.__proto__ = EventEmitter2.prototype;\n\n/**\n * @author Jihoon Lee- jihoonlee.in@gmail.com\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A static map that receives from map_server.\n *\n * Emits the following events:\n *   * 'change' - there was an update or change in the map\n *\n * @constructor\n * @param options - object with following keys:\n *   * ros - the ROSLIB.Ros connection handle\n *   * service (optional) - the map topic to listen to, like '/static_map'\n *   * rootObject (optional) - the root object to add this marker to\n */\nROS2D.OccupancyGridSrvClient = function(options) {\n  var that = this;\n  options = options || {};\n  var ros = options.ros;\n  var service = options.service || '/static_map';\n  this.rootObject = options.rootObject || new createjs.Container();\n\n  // current grid that is displayed\n  this.currentGrid = null;\n\n  // Setting up to the service\n  var rosService = new ROSLIB.Service({\n    ros : ros,\n    name : service,\n    serviceType : 'nav_msgs/GetMap',\n    compression : 'png'\n  });\n\n  rosService.callService(new ROSLIB.ServiceRequest(),function(response) {\n    // check for an old map\n    if (that.currentGrid) {\n      that.rootObject.removeChild(that.currentGrid);\n    }\n\n    that.currentGrid = new ROS2D.OccupancyGrid({\n      message : response.map\n    });\n    that.rootObject.addChild(that.currentGrid);\n\n    that.emit('change', that.currentGrid);\n  });\n};\nROS2D.OccupancyGridSrvClient.prototype.__proto__ = EventEmitter2.prototype;\n\n/**\n * @author Bart van Vliet - bart@dobots.nl\n */\n\n/**\n * An arrow with line and triangular head, based on the navigation arrow.\n * Aims to the left at 0 rotation, as would be expected.\n *\n * @constructor\n * @param options - object with following keys:\n *   * size (optional) - the size of the marker\n *   * strokeSize (optional) - the size of the outline\n *   * strokeColor (optional) - the createjs color for the stroke\n *   * fillColor (optional) - the createjs color for the fill\n *   * pulse (optional) - if the marker should \"pulse\" over time\n */\nROS2D.ArrowShape = function(options) {\n\tvar that = this;\n\toptions = options || {};\n\tvar size = options.size || 10;\n\tvar strokeSize = options.strokeSize || 3;\n\tvar strokeColor = options.strokeColor || createjs.Graphics.getRGB(0, 0, 0);\n\tvar fillColor = options.fillColor || createjs.Graphics.getRGB(255, 0, 0);\n\tvar pulse = options.pulse;\n\t\n\t// draw the arrow\n\tvar graphics = new createjs.Graphics();\n\t\n\tvar headLen = size / 3.0;\n\tvar headWidth = headLen * 2.0 / 3.0;\n\t\n\tgraphics.setStrokeStyle(strokeSize);\n\tgraphics.beginStroke(strokeColor);\n\tgraphics.moveTo(0, 0);\n\tgraphics.lineTo(size-headLen, 0);\n\t\n\tgraphics.beginFill(fillColor);\n\tgraphics.moveTo(size, 0);\n\tgraphics.lineTo(size-headLen, headWidth / 2.0);\n\tgraphics.lineTo(size-headLen, -headWidth / 2.0);\n\tgraphics.closePath();\n\tgraphics.endFill();\n\tgraphics.endStroke();\n\t\n\t// create the shape\n\tcreatejs.Shape.call(this, graphics);\n\t\n\t// check if we are pulsing\n\tif (pulse) {\n\t\t// have the model \"pulse\"\n\t\tvar growCount = 0;\n\t\tvar growing = true;\n\t\tcreatejs.Ticker.addEventListener('tick', function() {\n\t\t\tif (growing) {\n\t\t\t\tthat.scaleX *= 1.035;\n\t\t\t\tthat.scaleY *= 1.035;\n\t\t\t\tgrowing = (++growCount < 10);\n\t\t\t} else {\n\t\t\t\tthat.scaleX /= 1.035;\n\t\t\t\tthat.scaleY /= 1.035;\n\t\t\t\tgrowing = (--growCount < 0);\n\t\t\t}\n\t\t});\n\t}\n};\nROS2D.ArrowShape.prototype.__proto__ = createjs.Shape.prototype;\n\n/**\n * @author Raffaello Bonghi - raffaello.bonghi@officinerobotiche.it\n */\n\n/**\n * A Grid object draw in map.\n *\n * @constructor\n * @param options - object with following keys:\n *  * size (optional) - the size of the grid\n *  * cellSize (optional) - the cell size of map\n *  * lineWidth (optional) - the width of the lines in the grid\n */\n ROS2D.Grid = function(options) {\n    var that = this;\n    options = options || {};\n    var size = options.size || 10;\n    var cellSize = options.cellSize || 0.1;\n    var lineWidth = options.lineWidth || 0.001;\n    // draw the arrow\n    var graphics = new createjs.Graphics();\n    // line width\n    graphics.setStrokeStyle(lineWidth*5);\n    graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0));\n    graphics.beginFill(createjs.Graphics.getRGB(255, 0, 0));\n    graphics.moveTo(-size*cellSize, 0);\n    graphics.lineTo(size*cellSize, 0);\n    graphics.moveTo(0, -size*cellSize);\n    graphics.lineTo(0, size*cellSize);\n    graphics.endFill();\n    graphics.endStroke();\n\n    graphics.setStrokeStyle(lineWidth);\n    graphics.beginStroke(createjs.Graphics.getRGB(0, 0, 0));\n    graphics.beginFill(createjs.Graphics.getRGB(255, 0, 0));\n    for (var i = -size; i <= size; i++) {\n        graphics.moveTo(-size*cellSize, i * cellSize);\n        graphics.lineTo(size*cellSize, i * cellSize);\n        graphics.moveTo(i * cellSize, -size*cellSize);\n        graphics.lineTo(i * cellSize, size*cellSize);\n    }\n    graphics.endFill();\n    graphics.endStroke();\n    // create the shape\n    createjs.Shape.call(this, graphics);\n\n};\nROS2D.Grid.prototype.__proto__ = createjs.Shape.prototype;\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A navigation arrow is a directed triangle that can be used to display orientation.\n *\n * @constructor\n * @param options - object with following keys:\n *   * size (optional) - the size of the marker\n *   * strokeSize (optional) - the size of the outline\n *   * strokeColor (optional) - the createjs color for the stroke\n *   * fillColor (optional) - the createjs color for the fill\n *   * pulse (optional) - if the marker should \"pulse\" over time\n */\nROS2D.NavigationArrow = function(options) {\n  var that = this;\n  options = options || {};\n  var size = options.size || 10;\n  var strokeSize = options.strokeSize || 3;\n  var strokeColor = options.strokeColor || createjs.Graphics.getRGB(0, 0, 0);\n  var fillColor = options.fillColor || createjs.Graphics.getRGB(255, 0, 0);\n  var pulse = options.pulse;\n\n  // draw the arrow\n  var graphics = new createjs.Graphics();\n  // line width\n  graphics.setStrokeStyle(strokeSize);\n  graphics.moveTo(-size / 2.0, -size / 2.0);\n  graphics.beginStroke(strokeColor);\n  graphics.beginFill(fillColor);\n  graphics.lineTo(size, 0);\n  graphics.lineTo(-size / 2.0, size / 2.0);\n  graphics.closePath();\n  graphics.endFill();\n  graphics.endStroke();\n\n  // create the shape\n  createjs.Shape.call(this, graphics);\n  \n  // check if we are pulsing\n  if (pulse) {\n    // have the model \"pulse\"\n    var growCount = 0;\n    var growing = true;\n    createjs.Ticker.addEventListener('tick', function() {\n      if (growing) {\n        that.scaleX *= 1.035;\n        that.scaleY *= 1.035;\n        growing = (++growCount < 10);\n      } else {\n        that.scaleX /= 1.035;\n        that.scaleY /= 1.035;\n        growing = (--growCount < 0);\n      }\n    });\n  }\n};\nROS2D.NavigationArrow.prototype.__proto__ = createjs.Shape.prototype;\n\n/**\n * @author Inigo Gonzalez - ingonza85@gmail.com\n */\n\n/**\n * A navigation image that can be used to display orientation.\n *\n * @constructor\n * @param options - object with following keys:\n *   * size (optional) - the size of the marker\n *   * image - the image to use as a marker\n *   * pulse (optional) - if the marker should \"pulse\" over time\n */\nROS2D.NavigationImage = function(options) {\n  var that = this;\n  options = options || {};\n  var size = options.size || 10;\n  var image_url = options.image;\n  var pulse = options.pulse;\n  var alpha = options.alpha || 1;\n\n  var originals = {};\n\n  var paintImage = function(){\n    createjs.Bitmap.call(that, image);\n    var scale = calculateScale(size);\n    that.alpha = alpha;\n    that.scaleX = scale;\n    that.scaleY = scale;\n    that.regY = that.image.height/2;\n    that.regX = that.image.width/2;\n    originals['rotation'] = that.rotation;\n    Object.defineProperty( that, 'rotation', {\n      get: function(){ return originals['rotation'] + 90; },\n      set: function(value){ originals['rotation'] = value; }\n    });\n    if (pulse) {\n      // have the model \"pulse\"\n      var growCount = 0;\n      var growing = true;\n      var SCALE_SIZE = 1.020;\n      createjs.Ticker.addEventListener('tick', function() {\n        if (growing) {\n          that.scaleX *= SCALE_SIZE;\n          that.scaleY *= SCALE_SIZE;\n          growing = (++growCount < 10);\n        } else {\n          that.scaleX /= SCALE_SIZE;\n          that.scaleY /= SCALE_SIZE;\n          growing = (--growCount < 0);\n        }\n      });\n    }\n  };\n\n   var calculateScale = function(_size){\n      return _size / image.width;\n  };\n\n  var image = new Image();\n  image.onload = paintImage;\n  image.src = image_url;\n\n};\n\nROS2D.NavigationImage.prototype.__proto__ = createjs.Bitmap.prototype;\n\n/**\n * @author Bart van Vliet - bart@dobots.nl\n */\n\n/**\n * A shape to draw a nav_msgs/Path msg\n *\n * @constructor\n * @param options - object with following keys:\n *   * path (optional) - the initial path to draw\n *   * strokeSize (optional) - the size of the outline\n *   * strokeColor (optional) - the createjs color for the stroke\n */\nROS2D.PathShape = function(options) {\n\toptions = options || {};\n\tvar path = options.path;\n\tthis.strokeSize = options.strokeSize || 3;\n\tthis.strokeColor = options.strokeColor || createjs.Graphics.getRGB(0, 0, 0);\n\t\n\t// draw the line\n\tthis.graphics = new createjs.Graphics();\n\t\n\tif (path !== null && typeof path !== 'undefined') {\n\t\tthis.graphics.setStrokeStyle(this.strokeSize);\n\t\tthis.graphics.beginStroke(this.strokeColor);\n\t\tthis.graphics.moveTo(path.poses[0].pose.position.x / this.scaleX, path.poses[0].pose.position.y / -this.scaleY);\n\t\tfor (var i=1; i<path.poses.length; ++i) {\n\t\t\tthis.graphics.lineTo(path.poses[i].pose.position.x / this.scaleX, path.poses[i].pose.position.y / -this.scaleY);\n\t\t}\n\t\tthis.graphics.endStroke();\n\t}\n\t\n\t// create the shape\n\tcreatejs.Shape.call(this, this.graphics);\n};\n\n/**\n * Set the path to draw\n *\n * @param path of type nav_msgs/Path\n */\nROS2D.PathShape.prototype.setPath = function(path) {\n\tthis.graphics.clear();\n\tif (path !== null && typeof path !== 'undefined') {\n\t\tthis.graphics.setStrokeStyle(this.strokeSize);\n\t\tthis.graphics.beginStroke(this.strokeColor);\n\t\tthis.graphics.moveTo(path.poses[0].pose.position.x / this.scaleX, path.poses[0].pose.position.y / -this.scaleY);\n\t\tfor (var i=1; i<path.poses.length; ++i) {\n\t\t\tthis.graphics.lineTo(path.poses[i].pose.position.x / this.scaleX, path.poses[i].pose.position.y / -this.scaleY);\n\t\t}\n\t\tthis.graphics.endStroke();\n\t}\n};\n\nROS2D.PathShape.prototype.__proto__ = createjs.Shape.prototype;\n\n/**\n * @author Bart van Vliet - bart@dobots.nl\n */\n\n/**\n * A polygon that can be edited by an end user\n *\n * @constructor\n * @param options - object with following keys:\n *   * pose (optional) - the first pose of the trace\n *   * lineSize (optional) - the width of the lines\n *   * lineColor (optional) - the createjs color of the lines\n *   * pointSize (optional) - the size of the points\n *   * pointColor (optional) - the createjs color of the points\n *   * fillColor (optional) - the createjs color to fill the polygon\n *   * lineCallBack (optional) - callback function for mouse interaction with a line\n *   * pointCallBack (optional) - callback function for mouse interaction with a point\n */\nROS2D.PolygonMarker = function(options) {\n//\tvar that = this;\n\toptions = options || {};\n\tthis.lineSize = options.lineSize || 3;\n\tthis.lineColor = options.lineColor || createjs.Graphics.getRGB(0, 0, 255, 0.66);\n\tthis.pointSize = options.pointSize || 10;\n\tthis.pointColor = options.pointColor || createjs.Graphics.getRGB(255, 0, 0, 0.66);\n\tthis.fillColor = options.pointColor || createjs.Graphics.getRGB(0, 255, 0, 0.33);\n\tthis.lineCallBack = options.lineCallBack;\n\tthis.pointCallBack = options.pointCallBack;\n\t\n\t// Array of point shapes\n//\tthis.points = [];\n\tthis.pointContainer = new createjs.Container();\n\t\n\t// Array of line shapes\n//\tthis.lines = [];\n\tthis.lineContainer = new createjs.Container();\n\t\n\tthis.fillShape = new createjs.Shape();\n\t\n\t// Container with all the lines and points\n\tcreatejs.Container.call(this);\n\t\n\tthis.addChild(this.fillShape);\n\tthis.addChild(this.lineContainer);\n\tthis.addChild(this.pointContainer);\n};\n\n/**\n * Internal use only\n */\nROS2D.PolygonMarker.prototype.createLineShape = function(startPoint, endPoint) {\n\tvar line = new createjs.Shape();\n//\tline.graphics.setStrokeStyle(this.strokeSize);\n//\tline.graphics.beginStroke(this.strokeColor);\n//\tline.graphics.moveTo(startPoint.x, startPoint.y);\n//\tline.graphics.lineTo(endPoint.x, endPoint.y);\n\tthis.editLineShape(line, startPoint, endPoint);\n\t\n\tvar that = this;\n\tline.addEventListener('mousedown', function(event) {\n\t\tif (that.lineCallBack !== null && typeof that.lineCallBack !== 'undefined') {\n\t\t\tthat.lineCallBack('mousedown', event, that.lineContainer.getChildIndex(event.target));\n\t\t}\n\t});\n\t\n\treturn line;\n};\n\n/**\n * Internal use only\n */\nROS2D.PolygonMarker.prototype.editLineShape = function(line, startPoint, endPoint) {\n\tline.graphics.clear();\n\tline.graphics.setStrokeStyle(this.lineSize);\n\tline.graphics.beginStroke(this.lineColor);\n\tline.graphics.moveTo(startPoint.x, startPoint.y);\n\tline.graphics.lineTo(endPoint.x, endPoint.y);\n};\n\n/**\n * Internal use only\n */\nROS2D.PolygonMarker.prototype.createPointShape = function(pos) {\n\tvar point = new createjs.Shape();\n\tpoint.graphics.beginFill(this.pointColor);\n\tpoint.graphics.drawCircle(0, 0, this.pointSize);\n\tpoint.x = pos.x;\n\tpoint.y = -pos.y;\n\t\n\tvar that = this;\n\tpoint.addEventListener('mousedown', function(event) {\n\t\tif (that.pointCallBack !== null && typeof that.pointCallBack !== 'undefined') {\n\t\t\tthat.pointCallBack('mousedown', event, that.pointContainer.getChildIndex(event.target));\n\t\t}\n\t});\n\t\n\treturn point;\n};\n\n/**\n * Adds a point to the polygon\n *\n * @param position of type ROSLIB.Vector3\n */\nROS2D.PolygonMarker.prototype.addPoint = function(pos) {\n\tvar point = this.createPointShape(pos);\n\tthis.pointContainer.addChild(point);\n\tvar numPoints = this.pointContainer.getNumChildren();\n\t\n\t// 0 points -> 1 point, 0 lines\n\t// 1 point  -> 2 points, lines: add line between previous and new point, add line between new point and first point\n\t// 2 points -> 3 points, 3 lines: change last line, add line between new point and first point\n\t// 3 points -> 4 points, 4 lines: change last line, add line between new point and first point\n\t// etc\n\t\n\tif (numPoints < 2) {\n\t\t// Now 1 point\n\t}\n\telse if (numPoints < 3) {\n\t\t// Now 2 points: add line between previous and new point\n\t\tvar line = this.createLineShape(this.pointContainer.getChildAt(numPoints-2), point);\n\t\tthis.lineContainer.addChild(line);\n\t}\n\tif (numPoints > 2) {\n\t\t// Now 3 or more points: change last line\n\t\tthis.editLineShape(this.lineContainer.getChildAt(numPoints-2), this.pointContainer.getChildAt(numPoints-2), point);\n\t}\n\tif (numPoints > 1) {\n\t\t// Now 2 or more points: add line between new point and first point\n\t\tvar lineEnd = this.createLineShape(point, this.pointContainer.getChildAt(0));\n\t\tthis.lineContainer.addChild(lineEnd);\n\t}\n\t\n\tthis.drawFill();\n};\n\n/**\n * Removes a point from the polygon\n *\n * @param obj either an index (integer) or a point shape of the polygon\n */\nROS2D.PolygonMarker.prototype.remPoint = function(obj) {\n\tvar index;\n//\tvar point;\n\tif (obj instanceof createjs.Shape) {\n\t\tindex = this.pointContainer.getChildIndex(obj);\n//\t\tpoint = obj;\n\t}\n\telse {\n\t\tindex = obj;\n//\t\tpoint = this.pointContainer.getChildAt(index);\n\t}\n\t\n\t// 0 points -> 0 points, 0 lines\n\t// 1 point  -> 0 points, 0 lines\n\t// 2 points -> 1 point,  0 lines: remove all lines\n\t// 3 points -> 2 points, 2 lines: change line before point to remove, remove line after point to remove\n\t// 4 points -> 3 points, 3 lines: change line before point to remove, remove line after point to remove\n\t// etc\n\t\n\tvar numPoints = this.pointContainer.getNumChildren();\n\t\n\tif (numPoints < 2) {\n\t\t\n\t}\n\telse if (numPoints < 3) {\n\t\t// 2 points: remove all lines\n\t\tthis.lineContainer.removeAllChildren();\n\t}\n\telse {\n\t\t// 3 or more points: change line before point to remove, remove line after point to remove\n\t\tthis.editLineShape(\n\t\t\tthis.lineContainer.getChildAt((index-1+numPoints)%numPoints),\n\t\t\tthis.pointContainer.getChildAt((index-1+numPoints)%numPoints),\n\t\t\tthis.pointContainer.getChildAt((index+1)%numPoints)\n\t\t);\n\t\tthis.lineContainer.removeChildAt(index);\n\t}\n\tthis.pointContainer.removeChildAt(index);\n//\tthis.points.splice(index, 1);\n\t\n\tthis.drawFill();\n};\n\n/**\n * Moves a point of the polygon\n *\n * @param obj either an index (integer) or a point shape of the polygon\n * @param position of type ROSLIB.Vector3\n */\nROS2D.PolygonMarker.prototype.movePoint = function(obj, newPos) {\n\tvar index;\n\tvar point;\n\tif (obj instanceof createjs.Shape) {\n\t\tindex = this.pointContainer.getChildIndex(obj);\n\t\tpoint = obj;\n\t}\n\telse {\n\t\tindex = obj;\n\t\tpoint = this.pointContainer.getChildAt(index);\n\t}\n\tpoint.x = newPos.x;\n\tpoint.y = -newPos.y;\n\t\n\tvar numPoints = this.pointContainer.getNumChildren();\n\tif (numPoints > 1) {\n\t\t// line before moved point\n\t\tvar line1 = this.lineContainer.getChildAt((index-1+numPoints)%numPoints);\n\t\tthis.editLineShape(line1, this.pointContainer.getChildAt((index-1+numPoints)%numPoints), point);\n\t\t\n\t\t// line after moved point\n\t\tvar line2 = this.lineContainer.getChildAt(index);\n\t\tthis.editLineShape(line2, point, this.pointContainer.getChildAt((index+1)%numPoints));\n\t}\n\t\n\tthis.drawFill();\n};\n\n/**\n * Splits a line of the polygon: inserts a point at the center of the line\n *\n * @param obj either an index (integer) or a line shape of the polygon\n */\nROS2D.PolygonMarker.prototype.splitLine = function(obj) {\n\tvar index;\n\tvar line;\n\tif (obj instanceof createjs.Shape) {\n\t\tindex = this.lineContainer.getChildIndex(obj);\n\t\tline = obj;\n\t}\n\telse {\n\t\tindex = obj;\n\t\tline = this.lineContainer.getChildAt(index);\n\t}\n\tvar numPoints = this.pointContainer.getNumChildren();\n\tvar xs = this.pointContainer.getChildAt(index).x;\n\tvar ys = this.pointContainer.getChildAt(index).y;\n\tvar xe = this.pointContainer.getChildAt((index+1)%numPoints).x;\n\tvar ye = this.pointContainer.getChildAt((index+1)%numPoints).y;\n\tvar xh = (xs+xe)/2.0;\n\tvar yh = (ys+ye)/2.0;\n\tvar pos = new ROSLIB.Vector3({ x:xh, y:-yh });\n\t\n\t// Add a point in the center of the line to split\n\tvar point = this.createPointShape(pos);\n\tthis.pointContainer.addChildAt(point, index+1);\n\t++numPoints;\n\t\n\t// Add a line between the new point and the end of the line to split\n\tvar lineNew = this.createLineShape(point, this.pointContainer.getChildAt((index+2)%numPoints));\n\tthis.lineContainer.addChildAt(lineNew, index+1);\n\n\t// Set the endpoint of the line to split to the new point\n\tthis.editLineShape(line, this.pointContainer.getChildAt(index), point);\n\t\n\tthis.drawFill();\n};\n\n/**\n * Internal use only\n */\nROS2D.PolygonMarker.prototype.drawFill = function() {\n\tvar numPoints = this.pointContainer.getNumChildren();\n\tif (numPoints > 2) {\n\t\tvar g = this.fillShape.graphics;\n\t\tg.clear();\n\t\tg.setStrokeStyle(0);\n\t\tg.moveTo(this.pointContainer.getChildAt(0).x, this.pointContainer.getChildAt(0).y);\n\t\tg.beginStroke();\n\t\tg.beginFill(this.fillColor);\n\t\tfor (var i=1; i<numPoints; ++i) {\n\t\t\tg.lineTo(this.pointContainer.getChildAt(i).x, this.pointContainer.getChildAt(i).y);\n\t\t}\n\t\tg.closePath();\n\t\tg.endFill();\n\t\tg.endStroke();\n\t}\n\telse {\n\t\tthis.fillShape.graphics.clear();\n\t}\n};\n\n\nROS2D.PolygonMarker.prototype.__proto__ = createjs.Container.prototype;\n\n/**\n * @author Bart van Vliet - bart@dobots.nl\n */\n\n/**\n * A trace of poses, handy to see where a robot has been\n *\n * @constructor\n * @param options - object with following keys:\n *   * pose (optional) - the first pose of the trace\n *   * strokeSize (optional) - the size of the outline\n *   * strokeColor (optional) - the createjs color for the stroke\n *   * maxPoses (optional) - the maximum number of poses to keep, 0 for infinite\n *   * minDist (optional) - the minimal distance between poses to use the pose for drawing (default 0.05)\n */\nROS2D.TraceShape = function(options) {\n//\tvar that = this;\n\toptions = options || {};\n\tvar pose = options.pose;\n\tthis.strokeSize = options.strokeSize || 3;\n\tthis.strokeColor = options.strokeColor || createjs.Graphics.getRGB(0, 0, 0);\n\tthis.maxPoses = options.maxPoses || 100;\n\tthis.minDist = options.minDist || 0.05;\n\t\n\t// Store minDist as the square of it\n\tthis.minDist = this.minDist*this.minDist;\n\t\n\t// Array of the poses\n\t// TODO: do we need this?\n\tthis.poses = [];\n\t\n\t// Create the graphics\n\tthis.graphics = new createjs.Graphics();\n\tthis.graphics.setStrokeStyle(this.strokeSize);\n\tthis.graphics.beginStroke(this.strokeColor);\n\t\n\t// Add first pose if given\n\tif (pose !== null && typeof pose !== 'undefined') {\n\t\tthis.poses.push(pose);\n\t}\n\t\n\t// Create the shape\n\tcreatejs.Shape.call(this, this.graphics);\n};\n\n/**\n * Adds a pose to the trace and updates the graphics\n *\n * @param pose of type ROSLIB.Pose\n */\nROS2D.TraceShape.prototype.addPose = function(pose) {\n\tvar last = this.poses.length-1;\n\tif (last < 0) {\n\t\tthis.poses.push(pose);\n\t\tthis.graphics.moveTo(pose.position.x / this.scaleX, pose.position.y / -this.scaleY);\n\t}\n\telse {\n\t\tvar prevX = this.poses[last].position.x;\n\t\tvar prevY = this.poses[last].position.y;\n\t\tvar dx = (pose.position.x - prevX);\n\t\tvar dy = (pose.position.y - prevY);\n\t\tif (dx*dx + dy*dy > this.minDist) {\n\t\t\tthis.graphics.lineTo(pose.position.x / this.scaleX, pose.position.y / -this.scaleY);\n\t\t\tthis.poses.push(pose);\n\t\t}\n\t}\n\tif (this.maxPoses > 0 && this.maxPoses < this.poses.length) {\n\t\tthis.popFront();\n\t}\n};\n\n/**\n * Removes front pose and updates the graphics\n */\nROS2D.TraceShape.prototype.popFront = function() {\n\tif (this.poses.length > 0) {\n\t\tthis.poses.shift();\n\t\t// TODO: shift drawing instructions rather than doing it all over\n\t\tthis.graphics.clear();\n\t\tthis.graphics.setStrokeStyle(this.strokeSize);\n\t\tthis.graphics.beginStroke(this.strokeColor);\n\t\tthis.graphics.lineTo(this.poses[0].position.x / this.scaleX, this.poses[0].position.y / -this.scaleY);\n\t\tfor (var i=1; i<this.poses.length; ++i) {\n\t\t\tthis.graphics.lineTo(this.poses[i].position.x / this.scaleX, this.poses[i].position.y / -this.scaleY);\n\t\t}\n\t}\n};\n\nROS2D.TraceShape.prototype.__proto__ = createjs.Shape.prototype;\n\n/**\n * @author Bart van Vliet - bart@dobots.nl\n */\n\n/**\n * Adds panning to a view\n *\n * @constructor\n * @param options - object with following keys:\n *   * rootObject (optional) - the root object to apply panning to\n */\nROS2D.PanView = function(options) {\n\toptions = options || {};\n\tthis.rootObject = options.rootObject;\n\t\n\t// get a handle to the stage\n\tif (this.rootObject instanceof createjs.Stage) {\n\t\tthis.stage = this.rootObject;\n\t}\n\telse {\n\t\tthis.stage = this.rootObject.getStage();\n\t}\n\t\n\tthis.startPos = new ROSLIB.Vector3();\n};\n\n\nROS2D.PanView.prototype.startPan = function(startX, startY) {\n\tthis.startPos.x = startX;\n\tthis.startPos.y = startY;\n};\n\nROS2D.PanView.prototype.pan = function(curX, curY) {\n\tthis.stage.x += curX - this.startPos.x;\n\tthis.startPos.x = curX;\n\tthis.stage.y += curY - this.startPos.y;\n\tthis.startPos.y = curY;\n};\n\n/**\n * @author Russell Toris - rctoris@wpi.edu\n */\n\n/**\n * A Viewer can be used to render an interactive 2D scene to a HTML5 canvas.\n *\n * @constructor\n * @param options - object with following keys:\n *   * divID - the ID of the div to place the viewer in\n *   * width - the initial width, in pixels, of the canvas\n *   * height - the initial height, in pixels, of the canvas\n *   * background (optional) - the color to render the background, like '#efefef'\n */\nROS2D.Viewer = function(options) {\n  var that = this;\n  options = options || {};\n  var divID = options.divID;\n  this.width = options.width;\n  this.height = options.height;\n  var background = options.background || '#111111';\n\n  // create the canvas to render to\n  var canvas = document.createElement('canvas');\n  canvas.width = this.width;\n  canvas.height = this.height;\n  canvas.style.background = background;\n  document.getElementById(divID).appendChild(canvas);\n  // create the easel to use\n  this.scene = new createjs.Stage(canvas);\n\n  // change Y axis center\n  this.scene.y = this.height;\n\n  // add the renderer to the page\n  document.getElementById(divID).appendChild(canvas);\n\n  // update at 30fps\n  createjs.Ticker.setFPS(30);\n  createjs.Ticker.addEventListener('tick', this.scene);\n};\n\n/**\n * Add the given createjs object to the global scene in the viewer.\n *\n * @param object - the object to add\n */\nROS2D.Viewer.prototype.addObject = function(object) {\n  this.scene.addChild(object);\n};\n\n/**\n * Scale the scene to fit the given width and height into the current canvas.\n *\n * @param width - the width to scale to in meters\n * @param height - the height to scale to in meters\n */\nROS2D.Viewer.prototype.scaleToDimensions = function(width, height) {\n  // restore to values before shifting, if ocurred\n  this.scene.x = typeof this.scene.x_prev_shift !== 'undefined' ? this.scene.x_prev_shift : this.scene.x;\n  this.scene.y = typeof this.scene.y_prev_shift !== 'undefined' ? this.scene.y_prev_shift : this.scene.y;\n  \n  // save scene scaling\n  this.scene.scaleX = this.width / width;\n  this.scene.scaleY = this.height / height;\n};\n\n/**\n * Shift the main view of the canvas by the given amount. This is based on the\n * ROS coordinate system. That is, Y is opposite that of a traditional canvas.\n *\n * @param x - the amount to shift by in the x direction in meters\n * @param y - the amount to shift by in the y direction in meters\n */\nROS2D.Viewer.prototype.shift = function(x, y) {\n  // save current offset\n  this.scene.x_prev_shift = this.scene.x;\n  this.scene.y_prev_shift = this.scene.y;\n\n  // shift scene by scaling the desired offset\n  this.scene.x -= (x * this.scene.scaleX);\n  this.scene.y += (y * this.scene.scaleY);\n};\n\n/**\n * @author Bart van Vliet - bart@dobots.nl\n */\n\n/**\n * Adds zooming to a view\n *\n * @constructor\n * @param options - object with following keys:\n *   * rootObject (optional) - the root object to apply zoom to\n *   * minScale (optional) - minimum scale to set to preserve precision\n */\nROS2D.ZoomView = function(options) {\n\toptions = options || {};\n\tthis.rootObject = options.rootObject;\n\tthis.minScale = options.minScale || 0.001;\n\t\n\t// get a handle to the stage\n\tif (this.rootObject instanceof createjs.Stage) {\n\t\tthis.stage = this.rootObject;\n\t}\n\telse {\n\t\tthis.stage = this.rootObject.getStage();\n\t}\n\t\n\tthis.center = new ROSLIB.Vector3();\n\tthis.startShift = new ROSLIB.Vector3();\n\tthis.startScale = new ROSLIB.Vector3();\n};\n\n\nROS2D.ZoomView.prototype.startZoom = function(centerX, centerY) {\n\tthis.center.x = centerX;\n\tthis.center.y = centerY;\n\tthis.startShift.x = this.stage.x;\n\tthis.startShift.y = this.stage.y;\n\tthis.startScale.x = this.stage.scaleX;\n\tthis.startScale.y = this.stage.scaleY;\n};\n\nROS2D.ZoomView.prototype.zoom = function(zoom) {\n\t// Make sure scale doesn't become too small\n\tif (this.startScale.x*zoom < this.minScale) {\n\t\tzoom = this.minScale/this.startScale.x;\n\t}\n\tif (this.startScale.y*zoom < this.minScale) {\n\t\tzoom = this.minScale/this.startScale.y;\n\t}\n\t\n\tthis.stage.scaleX = this.startScale.x*zoom;\n\tthis.stage.scaleY = this.startScale.y*zoom;\n\t\n\tthis.stage.x = this.startShift.x - (this.center.x-this.startShift.x) * (this.stage.scaleX/this.startScale.x - 1);\n\tthis.stage.y = this.startShift.y - (this.center.y-this.startShift.y) * (this.stage.scaleY/this.startScale.y - 1);\n};\n\nexport default ROS2D",{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","severity":1,"message":"99","line":2,"column":33,"nodeType":"100","messageId":"101","endLine":2,"endColumn":45},{"ruleId":"98","severity":1,"message":"102","line":7,"column":31,"nodeType":"100","messageId":"101","endLine":7,"endColumn":37},{"ruleId":"98","severity":1,"message":"103","line":1,"column":10,"nodeType":"100","messageId":"101","endLine":1,"endColumn":24},{"ruleId":"104","severity":1,"message":"105","line":18,"column":9,"nodeType":"106","messageId":"107","endLine":18,"endColumn":19},{"ruleId":"104","severity":1,"message":"105","line":18,"column":9,"nodeType":"106","messageId":"107","endLine":18,"endColumn":19},{"ruleId":"98","severity":1,"message":"108","line":20,"column":9,"nodeType":"100","messageId":"101","endLine":20,"endColumn":12},{"ruleId":"98","severity":1,"message":"109","line":2,"column":15,"nodeType":"100","messageId":"101","endLine":2,"endColumn":24},{"ruleId":"98","severity":1,"message":"102","line":2,"column":31,"nodeType":"100","messageId":"101","endLine":2,"endColumn":37},{"ruleId":"104","severity":1,"message":"105","line":22,"column":9,"nodeType":"106","messageId":"107","endLine":22,"endColumn":19},{"ruleId":"104","severity":1,"message":"105","line":32,"column":5,"nodeType":"106","messageId":"107","endLine":32,"endColumn":15},{"ruleId":"110","severity":1,"message":"111","line":12,"column":13,"nodeType":"100","messageId":"112","endLine":12,"endColumn":18},{"ruleId":"110","severity":1,"message":"113","line":9,"column":13,"nodeType":"100","messageId":"112","endLine":9,"endColumn":18},{"ruleId":"98","severity":1,"message":"114","line":420,"column":9,"nodeType":"100","messageId":"101","endLine":420,"endColumn":13},{"ruleId":"98","severity":1,"message":"114","line":1067,"column":7,"nodeType":"100","messageId":"101","endLine":1067,"endColumn":11},"no-native-reassign",["115"],"no-negated-in-lhs",["116"],"no-unused-vars","'TabContainer' is defined but never used.","Identifier","unusedVar","'Button' is defined but never used.","'thisExpression' is defined but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","noDirectMutation","'nav' is assigned a value but never used.","'Container' is defined but never used.","no-use-before-define","'NAV2D' was used before it was defined.","usedBeforeDefined","'ROS2D' was used before it was defined.","'that' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]